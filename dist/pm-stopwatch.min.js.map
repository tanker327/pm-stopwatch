{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///pm-stopwatch.min.js","webpack:///webpack/bootstrap 73d7210f4a8b90a5b756","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","startTime","Symbol","stopTime","status","history","setHistory","STATUS","UNSTARTED","RUNNING","STOPPED","Stopwatch","message","isStopped","Error","isRunning","currentTime","Date","now","lapTime","arguments","undefined","type","lapInfo","timestamp","push","get","isStarted"],"mappings":"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","file":"pm-stopwatch.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PMStopwatch\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PMStopwatch\"] = factory();\n\telse\n\t\troot[\"PMStopwatch\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PMStopwatch\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PMStopwatch\"] = factory();\n\telse\n\t\troot[\"PMStopwatch\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar startTime = Symbol('start_time');\n\tvar stopTime = Symbol('stop_time');\n\tvar status = Symbol('running_status');\n\tvar history = Symbol('history');\n\tvar setHistory = Symbol('set_history');\n\t\n\tvar STATUS = {\n\t  UNSTARTED: Symbol('unstarted'),\n\t  RUNNING: Symbol('running'),\n\t  STOPPED: Symbol('stopped')\n\t};\n\t\n\tvar Stopwatch = function () {\n\t  function Stopwatch() {\n\t    _classCallCheck(this, Stopwatch);\n\t\n\t    this[status] = STATUS.UNSTARTED;\n\t    this[history] = [];\n\t  }\n\t\n\t  _createClass(Stopwatch, [{\n\t    key: 'start',\n\t    value: function start(message) {\n\t      if (this.isStopped) {\n\t        throw new Error('Stopwatch must be reset before being restarted.');\n\t      }\n\t      if (this.isRunning) {\n\t        throw new Error('Stopwatch is running. You cannot start it again.');\n\t      }\n\t      var currentTime = this[startTime] = this[stopTime] = Date.now();\n\t      this[setHistory](message, currentTime, 'start');\n\t      this[status] = STATUS.RUNNING;\n\t    }\n\t  }, {\n\t    key: 'stop',\n\t    value: function stop(message) {\n\t      if (!this.isRunning) {\n\t        throw new Error('Stopwatch is not running. You cannot stop it.');\n\t      }\n\t      this[setHistory](message, Date.now(), 'stop');\n\t      this[stopTime] = Date.now();\n\t      this[status] = STATUS.STOPPED;\n\t      return this[stopTime] - this[startTime];\n\t    }\n\t  }, {\n\t    key: 'reset',\n\t    value: function reset() {\n\t      this[status] = STATUS.UNSTARTED;\n\t      this[history].length = 0; // fast way to clean array\n\t    }\n\t  }, {\n\t    key: 'lap',\n\t    value: function lap(message) {\n\t      if (!this.isRunning) {\n\t        throw new Error('Stopwatch is not running.');\n\t      }\n\t\n\t      return this[setHistory](message).lapTime;\n\t    }\n\t  }, {\n\t    key: setHistory,\n\t    value: function value(message) {\n\t      var currentTime = arguments.length <= 1 || arguments[1] === undefined ? Date.now() : arguments[1];\n\t      var type = arguments.length <= 2 || arguments[2] === undefined ? 'lap' : arguments[2];\n\t\n\t      if (this.isStopped) {\n\t        throw new Error(\"The stopwatch is stopped. You can set history\");\n\t      }\n\t\n\t      var lapInfo = {\n\t        type: type,\n\t        message: message,\n\t        timestamp: currentTime,\n\t        lapTime: currentTime - this[stopTime]\n\t      };\n\t      this[stopTime] = currentTime;\n\t      this[history].push(lapInfo);\n\t      return lapInfo;\n\t    }\n\t  }, {\n\t    key: 'getLapHistory',\n\t    value: function getLapHistory() {\n\t      return this[history];\n\t    }\n\t  }, {\n\t    key: 'displayTime',\n\t    get: function get() {\n\t      if (this.isRunning) {\n\t        return Date.now() - this.startTime;\n\t      } else if (this.isStopped) {\n\t        return this.startTime - this.stopTime;\n\t      } else {\n\t        return 0;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'startTime',\n\t    get: function get() {\n\t      if (this.isStarted) {\n\t        return this[startTime];\n\t      } else {\n\t        throw new Error('Stopwatch is not running.');\n\t      }\n\t    }\n\t  }, {\n\t    key: 'stopTime',\n\t    get: function get() {\n\t      if (this.isStopped) {\n\t        return this[stopTime];\n\t      } else {\n\t        throw new Error('Stopwatch is still running or never run.');\n\t      }\n\t    }\n\t  }, {\n\t    key: 'isStarted',\n\t    get: function get() {\n\t      return this[status] !== STATUS.UNSTARTED;\n\t    }\n\t  }, {\n\t    key: 'isStopped',\n\t    get: function get() {\n\t      return this[status] === STATUS.STOPPED;\n\t    }\n\t  }, {\n\t    key: 'isRunning',\n\t    get: function get() {\n\t      return this[status] === STATUS.RUNNING;\n\t    }\n\t  }]);\n\t\n\t  return Stopwatch;\n\t}();\n\n\texports.default = Stopwatch;\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** pm-stopwatch.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 73d7210f4a8b90a5b756\n **/","const startTime = Symbol('start_time');\nconst stopTime = Symbol('stop_time');\nconst status = Symbol('running_status');\nconst history = Symbol('history');\nconst setHistory = Symbol('set_history');\n\nconst STATUS = {\n  UNSTARTED: Symbol('unstarted'),\n  RUNNING: Symbol('running'),\n  STOPPED: Symbol('stopped')\n};\n\n\nexport default class Stopwatch {\n  constructor() {\n    this[status] = STATUS.UNSTARTED;\n    this[history] = [];\n  }\n\n  start(message) {\n    if (this.isStopped) {\n      throw new Error('Stopwatch must be reset before being restarted.');\n    }\n    if (this.isRunning) {\n      throw new Error('Stopwatch is running. You cannot start it again.');\n    }\n    let currentTime = this[startTime] = this[stopTime] = Date.now();\n    this[setHistory](message, currentTime, 'start');\n    this[status] = STATUS.RUNNING;\n  }\n\n  stop(message) {\n    if (!this.isRunning) {\n      throw new Error('Stopwatch is not running. You cannot stop it.')\n    }\n    this[setHistory](message, Date.now(), 'stop');\n    this[stopTime] = Date.now();\n    this[status] = STATUS.STOPPED;\n    return this[stopTime] - this[startTime];\n  }\n\n  reset() {\n    this[status] = STATUS.UNSTARTED;\n    this[history].length = 0; // fast way to clean array\n  }\n\n  lap(message){\n    if (!this.isRunning) {\n      throw new Error('Stopwatch is not running.')\n    }\n\n    return this[setHistory](message).lapTime;\n  }\n\n  [setHistory](message, currentTime = Date.now(),type = 'lap'){\n    if(this.isStopped) {\n      throw new Error (\"The stopwatch is stopped. You can set history\");\n    }\n\n    let lapInfo = {\n      type:type,\n      message:message,\n      timestamp : currentTime,\n      lapTime : currentTime - this[stopTime]\n    };\n    this[stopTime] = currentTime;\n    this[history].push(lapInfo);\n    return lapInfo;\n  }\n\n  getLapHistory(){\n    return this[history];\n  }\n\n  get displayTime(){\n    if(this.isRunning){\n      return Date.now() - this.startTime;\n    }else if(this.isStopped) {\n      return this.startTime - this.stopTime;\n    }else{\n      return 0;\n    }\n  }\n\n  get startTime(){\n    if(this.isStarted) {\n      return this[startTime];\n    }else{\n      throw new Error('Stopwatch is not running.');\n    }\n  }\n\n  get stopTime(){\n    if(this.isStopped){\n      return this[stopTime];\n    }else{\n      throw new Error('Stopwatch is still running or never run.')\n    }\n\n  }\n\n  get isStarted(){\n    return this[status] !== STATUS.UNSTARTED;\n  }\n\n  get isStopped(){\n    return this[status] === STATUS.STOPPED;\n  }\n\n  get isRunning(){\n    return this[status] === STATUS.RUNNING;\n  }\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/"],"sourceRoot":""}